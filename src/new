use std::{
    collections::{HashMap, HashSet, VecDeque},
    fs,
    time::SystemTime
};

use rand::seq::SliceRandom;

#[derive(Debug)]
struct Graph {
    adjacency_list: HashMap<String, HashSet<String>>,
}

impl Graph {
    fn new() -> Self {
        Self {
            adjacency_list: HashMap::new(),
        }
    }

    fn add_edge(&mut self, node1: String, node2: String) {
        self.adjacency_list
            .entry(node1.clone())
            .or_insert_with(HashSet::new)
            .insert(node2.clone());
        self.adjacency_list
            .entry(node2)
            .or_insert_with(HashSet::new)
            .insert(node1);
    }


    }

    fn breadth_first_search(&self, node: String, depth:usize) -> HashSet<String> {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
    
        queue.push_back((node.clone(), 0));
    
        while let Some ((current_node, current_depth)) = queue.pop_front() {
            if visited.contains(&current_node) {
                continue;
            }
            visited.insert(current_node.clone());
    
            if current_depth >= depth {
                continue;
            }
            if let Some(neighbors) = self.adjacency_list.get(&current_node) {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        queue.push_back((neighbor.clone(), current_depth + 1))
                    }
                }
            }
        }
    
        visited

    }

    fn calculate_degrees(&self) -> HashMap<String, usize> {
        let mut degrees_map: HashMap<String, usize> = HashMap::new();
    
        for (node, neighbors) in &self.adjacency_list {
            let mut degree_count = neighbors.len();
    
            for neighbor in neighbors {
                if let Some(neighbor_neighbors) = self.adjacency_list.get(neighbor) {
                    degree_count += neighbor_neighbors.len() - 1;
                }
            }
    
            degrees_map.insert(node.clone(), degree_count);
        }
    
        degrees_map
    }
    
    fn find_interconnected_nodes(&self) -> HashSet<String> {
        let mut interconnected_nodes = HashSet::new();
    
        for (node, _) in &self.adjacency_list {
            let mut visited = HashSet::new();
            let mut to_visit = vec![node.clone()];
    
            while let Some(current_node) = to_visit.pop() {
                if visited.contains(&current_node) {
                    continue;
                }
    
                visited.insert(current_node.clone());
                if let Some(neighbors) = self.adjacency_list.get(&current_node) {
                    for neighbor in neighbors {
                        if !visited.contains(neighbor) {
                            to_visit.push(neighbor.clone());
                            interconnected_nodes.insert(neighbor.clone());
                        }
                    }
                }
            }
        }
    
        interconnected_nodes
    }


fn load_dataset(filename: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut graph = Graph::new();
    let content = fs::read_to_string(filename)?;

    let mut rng = rand::thread_rng();
    let nodes: Vec<&str> = content.lines().collect();
    let mut batches = nodes.chunks(1000).collect::<Vec<_>>();
    batches.shuffle(&mut rng);

    const BATCHES_TO_PROCESS: usize = 20;
    let mut total_overlap = 0;
    let mut total_followers = 0;

    for batch in batches.iter().take(BATCHES_TO_PROCESS) {
        for node in *batch {
            let direct_friends = {
                let temp = graph.adjacency_list.get(*node).unwrap_or(&HashSet::new());
                temp.clone()
            };
            let friends_of_friends = graph.breadth_first_search(node.to_string(), 2);

            let overlap = direct_friends.intersection(&friends_of_friends).count();
            total_overlap += overlap;
            total_followers += friends_of_friends.len();
        }
    }

    let average_overlap = total_overlap as f64 / total_followers as f64;
    println!("Average overlap: {:.2}", average_overlap);

    Ok(())
}




fn main() {
    
    let start_time = SystemTime::now();
    if let Err(err) = load_dataset("higgs_social_network.edgelist") {
        eprintln!("Error loading dataset: {}", err);
    }

    println!("Total time taken: {:?}", start_time.elapsed().unwrap());
}